package a_lambda;

import java.util.function.Function;

class LambdasCanCaptureVariablesFromTheirLexicalEnvironment {

    public static void main(String[] args) {
        CaptureTest captureTest = new CaptureTest(42);
        Function<Integer, String> func = captureTest.buildMeALambda();
        // The generated func object has 2 fields. One is the object where the lambda is created (captureTest)
        // the other is an int field containing the value of var. This is how the environment of the lambda is
        // captured. These fields are then used when calling apply(...)
        System.out.println(func.apply(5));

        // Run with -Djdk.internal.lambda.dumpProxyClasses=<path> in order to get the generated classes dumped to the
        // file system. File gets written in a directory starting with <path>/lambda/...

        // We see here that the actual lambda method stays with the object where the lambda is defined.

        /*
         * Decompiled generated object (Functional Interface)
         *
         * package learning.java.functional.interfaces;
         * 
         * import java.lang.invoke.LambdaForm.Hidden;
         * import java.util.function.Function;
         * import learning.java.functional.interfaces.LambdasCanCaptureVariablesFromTheirLexicalEnvironment.CaptureTest;
         * 
         * // $FF: synthetic class final
         * class LambdasCanCaptureVariablesFromTheirLexicalEnvironment$CaptureTest$$Lambda$1 implements Function {
         *   private final CaptureTest arg$1;
         *   private final int arg$2;
         * 
         *   private LambdasCanCaptureVariablesFromTheirLexicalEnvironment$CaptureTest$$Lambda$1(CaptureTest var1, int var2) {
         *     this.arg$1 = var1;
         *     this.arg$2 = var2;
         *   }
         * 
         * private static Function get$Lambda(CaptureTest var0, int var1) {
         *   return new LambdasCanCaptureVariablesFromTheirLexicalEnvironment$CaptureTest$$Lambda$1(var0, var1);
         * }
         * 
         * @Hidden public Object apply(Object var1) {
         *   //The actual lambda method stays with the object where the lambda is defined! return
         *   this.arg$1.lambda$buildMeALambda$0(this.arg$2, (Integer)var1);
         *   }
         * }
         */

        // Decompiling CaptureTest shows the private method reflecting the lambda generated by the compiler.
        // There is nothing special to this method adding -c to javap shows that.

        /*
         * javap -private .../LambdasCanCaptureVariablesFromTheirLexicalEnvironment\$CaptureTest.class
         * Compiled from "LambdasCanCaptureVariablesFromTheirLexicalEnvironment.java"
         * public class learning.java.functional.interfaces.LambdasCanCaptureVariablesFromTheirLexicalEnvironment$CaptureTest {
         *   private int field;
         *   public learning.java.functional.interfaces.LambdasCanCaptureVariablesFromTheirLexicalEnvironment$CaptureTest(int);
         *   public java.util.function.Function<java.lang.Integer,java.lang.String> buildMeALambda();
         *   private java.lang.String lambda$buildMeALambda$1(int, java.lang.Integer);
         *   }
         */
    }

    public static class CaptureTest {
        private int field;

        public CaptureTest(int fieldValue) {
            field = fieldValue;
        }

        public Function<Integer, String> buildMeALambda() {
            int var = field * 2;
            return (param) -> "Values are: " + var + " - " + field * param;
        }

    }
}
